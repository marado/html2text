Recode input according to 'meta http-equiv' in html document.
Index: html2text-1.3.2a/html2text.C
===================================================================
--- html2text-1.3.2a.orig/html2text.C	2008-09-13 16:56:02.202610597 +0300
+++ html2text-1.3.2a/html2text.C	2008-09-13 17:51:58.424416161 +0300
@@ -37,10 +37,16 @@
 
 #include <iostream>
 #include <fstream>
+#include <sstream>
+#include <algorithm>
+#include <iterator>
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
 
+#include <iconv.h>
+#include <errno.h>
+
 #include "html.h"
 #include "HTMLControl.h"
 //#include "urlistream.h"
@@ -51,11 +57,15 @@
 
 /* ------------------------------------------------------------------------- */
 using std::ifstream;
+using std::stringstream;
+using std::istream_iterator;
+using std::ostream_iterator;
 
 class MyParser : public HTMLControl {
 
 public:
   enum { PRINT_AS_ASCII, UNPARSE, SYNTAX_CHECK };
+  string meta_encoding;
 
   MyParser(
     istream &is_,
@@ -107,6 +117,23 @@
 /*virtual*/ void
 MyParser::process(const Document &document)
 {
+  list<auto_ptr<Meta> >::const_iterator i;
+  for(i = document.head.metas.begin(); i != document.head.metas.end(); ++i) {
+    bool exists = false;
+    get_attribute(i->get()->attributes.get(), "http-equiv", &exists);
+    if (exists) {
+      string content = get_attribute(i->get()->attributes.get(), "content", "");
+	  char to_find[] = "charset=";
+	  string::size_type found_pos = content.find(to_find);
+	  if (found_pos != string::npos)
+	  {
+        this->meta_encoding = content.substr(found_pos + sizeof(to_find) - 1);
+	    //std::cerr << this->meta_encoding << std::endl;
+	  }
+      break;
+    }
+  }
+
   switch (mode) {
 
   case PRINT_AS_ASCII:
@@ -152,6 +179,7 @@
   -nobs          Do not use backspaces for boldface and underlining\n\
   -ascii         Use plain ASCII for output instead of ISO-8859-1\n\
   -utf8          Assume both terminal and input stream are in UTF-8 mode\n\
+  -nometa        Don't try to recode input using 'meta' tag\n\
 ";
 
 int use_encoding = ISO8859;
@@ -189,6 +217,7 @@
   int        width             = 79;
   const char *output_file_name = "-";
   bool       use_backspaces    = true;
+  bool       use_meta          = true;
 
   int i;
   for (i = 1; i < argc && argv[i][0] == '-' && argv[i][1]; i++) {
@@ -205,6 +234,7 @@
     if (!strcmp(arg, "-nobs"         )) { use_backspaces = false;        } else
     if (!strcmp(arg, "-ascii"        )) { use_encoding = ASCII;          } else
     if (!strcmp(arg, "-utf8"         )) { use_encoding = UTF8;           } else
+    if (!strcmp(arg, "-nometa"       )) { use_meta = false;              } else
     {
       std::cerr
 	<< "Unrecognized command line option \""
@@ -214,6 +244,10 @@
       exit(1);
     }
   }
+  if (use_meta)
+  {
+    use_encoding = UTF8;
+  }
   if (use_encoding == UTF8)
   {
 	  use_backspaces = false;
@@ -365,30 +399,141 @@
     }
 
     istream    *isp;
-    ifstream     uis;
-
-    uis.open(input_url);
-    if (!uis.is_open()) {
-      std::cerr
-        << "Cannot open input file \""
-	<< input_url
-        << "\"."
-        << std::endl;
-      exit(1);
+    istream    *uis;
+	ifstream* infile = NULL;
+	stringstream input_stream;
+
+	if (strcmp(input_url, "-") == 0)
+	{
+		uis = &std::cin;
+	}
+	else
+	{
+		infile = new ifstream(input_url);
+		if (!infile->is_open())
+		{
+		  delete infile;
+		  std::cerr
+			<< "Cannot open input file \""
+			<< input_url
+			<< "\"."
+			<< std::endl;
+		  exit(1);
+		}
+		uis = infile;
     }
 
-    MyParser parser(
-      uis,
-      debug_scanner,
-      debug_parser,
-      *osp,
-      mode,
-      width,
-      input_url
-    );
+	*uis >> std::noskipws;
+	std::copy(istream_iterator<char>(*uis), istream_iterator<char>(), ostream_iterator<char>(input_stream));
+
+	if (use_meta)
+	{
+		std::ofstream fake_osp("/dev/null");
+		// fake parsing to determine meta
+		MyParser parser(
+		  input_stream,
+		  debug_scanner,
+		  debug_parser,
+		  fake_osp,
+		  mode,
+		  width,
+		  input_url
+        );
+		if (parser.yyparse() != 0) exit(1);
+
+		if (!parser.meta_encoding.empty()) // recode input
+		{
+			iconv_t iconv_handle = iconv_open("UTF-8", parser.meta_encoding.data());
+			if (iconv_handle != iconv_t(-1))
+			{
+				input_stream.seekg(0);
+				string input_string = input_stream.str();
+				size_t input_size = input_string.size();
+				char* raw_input = new char[input_size+1];
+				char* const orig_raw_input = raw_input;
+				strcpy(raw_input, input_string.data());
+				size_t max_output_size = input_size * 4; // maximum possible overhead
+				char* raw_output = new char[max_output_size+1];
+				char* const orig_raw_output = raw_output;
+				size_t iconv_value =
+					iconv(iconv_handle, &raw_input, &input_size, &raw_output, &max_output_size);
+
+				if (iconv_value != (size_t)-1)
+				{
+					input_stream.str(string(orig_raw_output));
+					input_stream.clear();
+					input_stream.seekg(0);
+					/* debug */
+					//std::copy(istream_iterator<char>(input_stream), istream_iterator<char>(), ostream_iterator<char>(std::cerr));
+				}
+
+				delete [] orig_raw_input;
+				delete [] orig_raw_output;
+				iconv_close(iconv_handle);
+
+				if (iconv_value == (size_t)-1)
+				{
+					std::cerr << "Input recoding failed due to ";
+					if (errno == EILSEQ)
+					{
+						std::cerr << "invalid input sequence.";
+						/* debug */
+						std::cout << raw_input;
+					}
+					else
+					{
+						std::cerr << "unknown reason.";
+					}
+					std::cerr << std::endl;
+					continue;
+				}
+			}
+			else
+			{
+				if (errno == EINVAL)
+				{
+					std::cerr << "Recoding from '" << parser.meta_encoding
+						<< "' to 'UTF-8' is not available." << std::endl;
+					std::cerr << "Check that '" << parser.meta_encoding
+						<< "' is a valid encoding." << std::endl;
+				}
+				else
+				{
+					std::cerr << "Error: cannot setup recoding." << std::endl;
+				}
+				continue;
+			}
+		}
+		else
+		{
+			std::cerr << "Error: cannot determine encoding from html file." << std::endl;
+			std::cerr << "Use '-nometa' option with, optionally, '-utf8' or '-ascii' options" << std::endl;
+			std::cerr << "to process file \"" << input_url << "\"." << std::endl;
+			continue;
+		}
+	}
+
+    if (number_of_input_urls != 1) {
+      *osp << "###### " << input_url << " ######" << std::endl;
+    }
 
+	// real parsing
+	MyParser parser(
+	  input_stream,
+	  debug_scanner,
+	  debug_parser,
+	  *osp,
+	  mode,
+	  width,
+	  input_url
+	);
     if (parser.yyparse() != 0) exit(1);
-	uis.close();
+
+	if (infile)
+	{
+		infile->close();
+		delete infile;
+	}
   }
 
   return 0;
