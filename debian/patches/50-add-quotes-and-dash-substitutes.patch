Index: html2text-1.3.2a/ascii.substitutes
===================================================================
--- html2text-1.3.2a.orig/ascii.substitutes	2008-07-13 17:20:46.933266658 +0300
+++ html2text-1.3.2a/ascii.substitutes	2008-07-13 17:20:48.045253865 +0300
@@ -253,3 +253,9 @@
 &rceil;   ">|"
 &rfloor;  "|>"
 &spades;  "[spades]"
+
+/* added by Eugene V. Lyubimkin for Debian */
+
+&#8220;   "``"
+&#8221;   "''"
+&#8212;   "--"
Index: html2text-1.3.2a/sgml.C
===================================================================
--- html2text-1.3.2a.orig/sgml.C	2008-07-13 17:20:46.949264571 +0300
+++ html2text-1.3.2a/sgml.C	2008-07-13 17:30:26.417979309 +0300
@@ -63,6 +63,9 @@
   int  iso8859code;
   char *asciistr;
 } entities[] = {
+  { "#8212",   0,             "--"         },
+  { "#8220",   0,             "``"         },
+  { "#8221",   0,             "''"         },
   { "AElig",   LATIN1_AElig,  "AE"         },
   { "AMP",     0,             "&"          },
   { "Aacute",  LATIN1_Aacute, "A'"         },
@@ -355,40 +358,12 @@
      * Look at the next character.
      */
     char c = s->at(j++);
-    if (c == '#') {
+	string::size_type old_j = j;
+	bool yet_need_translating = true;
+    if (isalpha(c) || c == '#') {
 
       /*
-       * Decode entities like "&#233;".
-       * Some authors forget the ";", but we tolerate this.
-       */
-      c = s->at(j++);
-      if (isdigit(c)) {
-        int x = c - '0';
-        for (; j < l; ++j) {
-          c = s->at(j);
-          if (c == ';') { ++j; break; }
-          if (!isdigit(c)) break;
-          x = 10 * x + c - '0';
-        }
-        if (use_iso8859 || (x < 128)) {
-        s->replace(beg, j - beg, 1, (char) x);
-        j = beg + 1;
-        } else {
-          for (int i = 0; i < nelems(entities); i++) {
-            if (x == entities[i].iso8859code) {
-              s->replace(beg, j - beg, entities[i].asciistr);
-              break;
-            }
-          }
-          /* else don't replace it at all, we don't have a translation */
-        }
-      }
-    } else
-
-    if (isalpha(c)) {
-
-      /*
-       * Decode entities like "&nbsp;".
+       * Decode entities like "&nbsp;" and "&#8220;".
        * Some authors forget the ";", but we tolerate this.
        */
       char name[8];
@@ -410,15 +385,50 @@
       if (entity != NULL) {
         if (use_iso8859 && entity->iso8859code) {
           s->replace(beg, j - beg, 1, (char) entity->iso8859code);
+		  yet_need_translating = false;
           j = beg + 1;
         } else if (entity->asciistr) {
           s->replace(beg, j - beg, entity->asciistr);
+		  yet_need_translating = false;
         j = beg + 1;
         } /* else don't replace it at all, we don't have a translation */
       }
-    } else {
-      ;                         /* EXTENSION: Allow literal '&' sometimes. */
-    }
+	}
+	if (yet_need_translating) {
+		j = old_j;
+		c = s->at(j-1);
+		if (c == '#') {
+
+		  /*
+		   * Decode entities like "&#233;".
+		   * Some authors forget the ";", but we tolerate this.
+		   */
+		  c = s->at(j++);
+		  if (isdigit(c)) {
+			int x = c - '0';
+			for (; j < l; ++j) {
+			  c = s->at(j);
+			  if (c == ';') { ++j; break; }
+			  if (!isdigit(c)) break;
+			  x = 10 * x + c - '0';
+			}
+			if (use_iso8859 || (x < 128)) {
+			s->replace(beg, j - beg, 1, (char) x);
+			j = beg + 1;
+			} else {
+			  for (int i = 0; i < nelems(entities); i++) {
+				if (x == entities[i].iso8859code) {
+				  s->replace(beg, j - beg, entities[i].asciistr);
+				  break;
+				}
+			  }
+			  /* else don't replace it at all, we don't have a translation */
+			}
+		  }
+		} else {
+		  ;                         /* EXTENSION: Allow literal '&' sometimes. */
+		}
+	}
   }
 }
 
